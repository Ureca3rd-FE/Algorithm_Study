메모리: 97272KB<br>
시간: 376ms


# 풀이
## 1차 접근
666의 앞과 뒤를 분리하고 앞/뒤를 1씩 늘려 비교하며 더 작은 숫자를 찾아갈 예정이었음.

### 문제점
- back이 없는 경우, front가 없는 경우, 특정 수를 넘어갈 때 front와 back을 어떻게 초기화하여 수를 찾을 것이냐 등 따져야할 게 많아짐.
- 찾아보니 저렇게 풀려면 `문제에서 주어지는 숫자가 그리 크지 않으니까 경우에 맞춰 자릿수별로 따로 생각하여 구현` 필요.
- 하지만 브루트 포스가 왜 브루트 포스인가? 이렇게 푸는 건 아닌 것 같아 다른 방법을 찾았다.

### 2차 접근
1. 숫자를 1부터 증가시키면서 666이 들어가면 count를 1 올린다.
2. count가 n에 도달할 때까지 반복한다.