메모리: 125592KB<br>
시간: 1860ms

# 풀이
## 접근
문제 이해가 조금 어려웠다.
1. 처음에 수열에 나올 숫자의 개수 n이 나온다.
2. 그 다음 n줄이 만들어야 하는 수열이다. (1이상 n 이하, 중복x)
3. stack엔 오름차순으로 숫자가 들어간다. 수열에 필요한 숫자가 나오면 stack을 pop하고 아니면 add한다.

예시를 정리하면 다음과 같다.
```java
3개의 숫자가 나오고 만들어야 하는 수열이 2, 3 ,1이면
+: stack[1]
+: stack[1,2]
-: stack[1] result[2]
+: stack[1,3] result[2]
-: stack[1] result[2,3]
-: stack[] result[2,3,1]
```
이런 식

구현은 다음과 같이 한다.
1. n을 받는다.
2. count가 n에 도달할 때까지 반복문을 돌린다.
3. stack이 비지 않았고, peek이 비교할 수와 같으면 pop/count 증가/비교할 수 갱신
4. stack이 비었거나, peek이 비교할 수와 다르면 add/stack에 넣을 수 증가
5. 이 과정을 반복해서 count가 n이 될 때까지 

### 문제점
- 불가능한 경우(stack.peek에서 비교할 수가 끝까지 나오지 않는 상황)를 생각하지 않음.

**구현 변경**<br>
Stack의 peek가
1. 비교할 수보다 `작으면` 스택 add.
2. 비교할 수와 `같으면` 스택 pop.
3. 비교할 수보다 `크면` NO 판단.

**외에도**
- 원래 비교할 수를 즉시 sc.nextInt()하여 가져왔는데 마지막 숫자를 비교할 때 없는 숫자를 읽어오려고 하여 대기가 걸림.
    - 해당 로직을 수정해 비교할 수들의 배열을 만든다. 나온 수열 수를 판단하던 count를 index로 사용.<br><br>
- 원래 1로 초기값을 넣어 peek와 비교할 수 있도록 했는데, 수열이 [1,2,3,...]이면 초기값을 넣어도 바로 비어버려 peek를 볼 때 empty stack이 된다.
    - stack에 초기값 넣던 걸 지우고 비었으면 add하도록 처리.<br><br>
- +, -를 출력하다 안 될 때 NO를 출력하는 것이 아니기 때문에 command 배열과 ok boolean을 따로 둠.
    - command에 +, - 동작이 들어감
    - ok에 수열을 만들 수 있는지 없는지 들어감.